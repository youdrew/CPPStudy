// 纯虚函数：通过继承和虚函数来实现运行时的多态性。
// Created by Youdrew on 2022/2/4.
/*
 * 纯虚函数 和 虚函数 是不一样的
定义一个函数为【虚函数】，不代表函数为不被实现的函数。定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
定义一个函数为【纯虚函数】，才代表函数没有被实现。定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

纯虚函数用于做接口，它一定是一个虚函数（有virtual关键字）
 */
// https://www.runoob.com/w3cnote/cpp-virtual-functions.html


// 回忆多态性：
// C++支持两种多态性:编译时多态性,运行时多态性。
        // a编译时多态性:通过函数重载和运算符重载来实现的。
        // b运行时多态性:通过继承和虚函数来实现的。

#include <iostream>
#include "Vehicle.h"    //这是父类
#include "tesla.h"      //这是子类,这里面包含"继承的重写"、"virtual关键字"等知识点
using namespace std;

class Ship{
public:
    virtual void driveMyBWM()=0;
    // 纯虚函数没有函数体，只有函数声明，在虚函数声明的结尾加上 =0，表明此函数为纯虚函数。
    // 包含纯虚函数的类称为抽象类（Abstract Class）。之所以说它抽象，是因为它无法实例化，也就是无法创建对象。
    // 原因很明显，纯虚函数没有函数体，不是完整的函数，无法调用，也无法为其分配内存空间。
    // 抽象类通常是作为基类，让派生类去实现纯虚函数。派生类必须实现纯虚函数才能被实例化。这样的"霸王条款"，要求派生类要实现多态性。

    // 定义纯虚函数的目的在于，使派生类仅仅只是继承函数的接口。
    // 纯虚函数的意义，让所有的类对象（主要是派生类对象）都可以执行纯虚函数的动作，但类无法为纯虚函数提供一个合理的默认实现。
    // 所以类纯虚函数的声明就是在告诉子类的设计者，"你必须提供一个纯虚函数的实现，但我不知道你会怎样实现它"。
};

class BMW:public Vehicle{
public:
    virtual int PrueVirtualFunction(){
        cout << "BWM执行了这个纯虚函数" << endl;
    }
};


// 这里写一下利用纯虚函数实现多态
int main(){
    Vehicle *ptr[4];    // 不可以声明抽象类的对象，但可以声明抽象类的指针。

    for (int i = 0; i < 4; ++i) {
        int t;
        cout << "请输入你的财务状况（1为有钱，0为没钱）" << endl;
        cin >> t;
        if (t==1)                // ⚠️ 这里就是在建立动态绑定，我们不知道它接下来要选择什么。不同选择调用不同的函数。
            ptr[i] = new tesla;
        else
            ptr[i] = new BMW;
    }

    for (int i = 0; i < 4; ++i) {
        ptr[i]->PrueVirtualFunction();  //这个函数在基类中是一个"纯虚函数"
        cout << endl << endl;
    }
}